#include <Arduino.h>
#include <FS.h> 
#include <fauxmoESP.h> // https://github.com/makermusings/fauxmo (Fauxmo commit 54e00be from GitHub)
#include <ESP8266WiFi.h> // https://github.com/tzapu/WiFiManager (WiFiManager-0.12.0 from Arduino IDE Libraries)
#include <WiFiManager.h> 
#include <PubSubClient.h> // http://pubsubclient.knolleary.net/ (PubSubClient-2.6.0 from Arduino IDE Libraries)
#include <ESP8266WebServer.h> 

#include "credentials.h" // Copy credentials.h.example to credentials.h and fill with your private data

// Using latests Arduino/hardware/esp8266 tools from https://github.com/esp8266/Arduino (commit 7b32e6a)

// Pin to name mapping
// If you have your I/O connected to other pin, modify this accordingly
#define SWITCH_PIN D5

// Fauxmo (Faux Wemo) device name that can be discovered by Amazon Alexa
#define FAUXMO_DEVICE_NAME "Christmas Lights"

// Adafruit IO configuration. Replace {user} and {key} with your own
#define AIO_SERVER "io.adafruit.com"
#define AIO_SERVERPORT 1883
#define AIO_USERNAME AIO_CRED_USERNAME
#define AIO_KEY AIO_CRED_KEY

// Adafruit IO feed (they are autogenerated using the device id)
// Example for the switch: AIO_BASE_FEED + ESP.getChipId() + AIO_SWITCH_FEED =>
// {username}/feeds/CC44DD-switch. No need to change these.
#define AIO_BASE_FEED AIO_USERNAME "/feeds/"
#define AIO_SWITCH_FEED "-switch"

// Serial speed for the console
#define SERIAL_SPEED 115200

// MQTT connection
WiFiClient espClient;
PubSubClient client(espClient);
String switchFeed;

// FauxmoESP
fauxmoESP fauxmo;

// Web server
ESP8266WebServer server(80);

// State
int switchState = 0;
char chipId[6];

void setSwitchHigh(bool publish) {
    digitalWrite(SWITCH_PIN, HIGH);

    switchState = 1;

    Serial.println("Switch: HIGH");

    if (publish) {
        publishSwitch();
    }
}

void setSwitchLow(bool publish) {
    digitalWrite(SWITCH_PIN, LOW);

    switchState = 0;

    Serial.println("Switch: LOW");

    if (publish) {
        publishSwitch();
    }
}

void publishSwitch(void) {
    String switchStateString;
    switchStateString += switchState;

    client.publish(switchFeed.c_str(), switchStateString.c_str());

    Serial.print("Publish message [");
    Serial.print(switchFeed);
    Serial.print("]: ");
    Serial.println(switchStateString);
}

String getContentType(String filename) {
    if (server.hasArg("download"))
        return "application/octet-stream";
    else if (filename.endsWith(".htm"))
        return "text/html";
    else if (filename.endsWith(".html"))
        return "text/html";
    else if (filename.endsWith(".css"))
        return "text/css";
    else if (filename.endsWith(".js"))
        return "application/javascript";
    else if (filename.endsWith(".png"))
        return "image/png";
    else if (filename.endsWith(".gif"))
        return "image/gif";
    else if (filename.endsWith(".jpg"))
        return "image/jpeg";
    else if (filename.endsWith(".ico"))
        return "image/x-icon";
    else if (filename.endsWith(".xml"))
        return "text/xml";
    else if (filename.endsWith(".pdf"))
        return "application/x-pdf";
    else if (filename.endsWith(".zip"))
        return "application/x-zip";
    else if (filename.endsWith(".gz"))
        return "application/x-gzip";
    else if (filename.endsWith(".svg"))
        return "image/svg+xml";

    return "text/plain";
}

bool handleFileRead(String path) {
    Serial.println("handleFileRead: " + path);
    if (path.endsWith("/")) path += "index.min.html";

    String contentType = getContentType(path);

    String pathWithGz = path + ".gz";

    if (SPIFFS.exists(pathWithGz) || SPIFFS.exists(path)) {
        if (SPIFFS.exists(pathWithGz)) path += ".gz";
        File file = SPIFFS.open(path, "r");
        size_t sent = server.streamFile(file, contentType);
        file.close();
        return true;
    }

    return false;
}

void returnActionValue(void( * action)(bool), bool value) {
    action(value);
    server.send(200, "application/json", "true");
}

void mqttCallback(char * topicChar, byte * payloadBytes, unsigned int length) {
    char payloadChar[100];
    int i;
    for (i = 0; i < length; i++) {
        payloadChar[i] = payloadBytes[i];
    }
    payloadChar[i] = '\0';

    String topic = String(topicChar);
    String payload = String(payloadChar);

    Serial.print("Message arrived [");
    Serial.print(topic);
    Serial.print("] (");
    Serial.print(length);
    Serial.print(" bytes) :");
    Serial.print(payload);
    Serial.println();

    if (topic == switchFeed) {
        Serial.print("Processing ");
        Serial.println(switchFeed);

        if ((char) payload[0] == '0') {
            setSwitchLow(false);
        } else {
            setSwitchHigh(false);
        }
    } 
}

String setFeedId(const char * base, char * id, const char * feed) {
    String feedId;
    feedId += base;
    feedId += id;
    feedId += feed;

    return feedId;
}

void setupFeedIds(void) {
    switchFeed = setFeedId(AIO_BASE_FEED, chipId, AIO_SWITCH_FEED);
}

void handleMqttConnection(void) {
    // Loop until we're reconnected
    while (!client.connected()) {
        Serial.print("Attempting MQTT connection...");
        // Attempt to connect
        if (client.connect(chipId, AIO_USERNAME, AIO_KEY)) {
            Serial.println("connected");
            // Publish current state
            publishSwitch();
            // Resubscribe
            client.subscribe(switchFeed.c_str());
        } else {
            Serial.print("failed, ClientState=");
            Serial.print(client.state());
            Serial.println(" trying again in 5000 milliseconds");
            // Wait 5 seconds before retrying but continue handling we requests
            long retryMillis = millis() + 5000;
            while (millis() < retryMillis) {
                // Keep processing local server calls in the meantime
                server.handleClient();
            }
        }
    }
    client.loop();
}

void setup(void) {
    // Init serial
    Serial.begin(SERIAL_SPEED);
    sprintf(chipId, "%06X", ESP.getChipId());
    Serial.println("");
    Serial.print("----- ESP ID=");
    Serial.print(chipId);
    Serial.println(" -----");

    // Setup pins
    pinMode(SWITCH_PIN, OUTPUT);

    // Connect to WiFi / AP
    WiFiManager wifiManager;
    wifiManager.autoConnect();

    // Setup MQTT
    setupFeedIds();
    client.setServer(AIO_SERVER, AIO_SERVERPORT);
    client.setCallback(mqttCallback);

    // Setup file system
    SPIFFS.begin();

    // Setup chip id
    if (!SPIFFS.exists("/id.json")) {
        File idFile = SPIFFS.open("/id.json", "w");
        if (!idFile) {
            Serial.println("id.json file failed to open");
        }
        idFile.println(chipId);
        idFile.close();
    }

    // Set up HTTP server handles
    server.on("/setSwitchHigh", []() {
        returnActionValue(setSwitchHigh, true);
    });
    server.on("/setSwitchLow", []() {
        returnActionValue(setSwitchLow, true);
    });
    server.on("/getSwitch", []() {
        String switchAsString;
        switchAsString += switchState;
        server.send(200, "application/json", switchAsString);
    });
    server.on("/setId", []() {
        File idFile = SPIFFS.open("/id.json", "w");
        if (!idFile) {
            Serial.println("id.json file failed to open");
            server.send(500, "application/json", "false");
        } else {
            idFile.println(server.arg("id"));
            server.send(200, "application/json", "true");
        }
        idFile.close();
    });

    server.onNotFound([]() {
        if (!handleFileRead(server.uri())) {
            server.send(404, "text/plain", "FileNotFound");
        }
    });

    // Start HTTP server
    server.begin();
    Serial.println("HTTP server started");

    // Fauxmo
    fauxmo.addDevice(FAUXMO_DEVICE_NAME);
    fauxmo.onMessage([](const char * device_name, bool state) {
        Serial.printf("New WeMo message for device %s, new state: %s", device_name, state ? "ON" : "OFF");
        if (state == 1) {
            setSwitchHigh(true);
        } else {
            setSwitchLow(true);
        }
    });
}

void loop() {
    handleMqttConnection();handleMqttConnection();
    server.handleClient();
}
